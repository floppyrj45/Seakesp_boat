<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Seakesp Boat - Carte</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root{
      --fg:#0b1220;           /* texte par défaut (mode clair) */
      --fg-muted:#334155;
      --card-bg:rgba(255,255,255,0.9);
      --card-brd:1px solid rgba(0,0,0,0.12);
      --chip-bg:#ffffff;
      --chip-fg:#0b1220;
      --accent:#2563eb;       /* bleu */
      --accent-2:#10b981;     /* vert */
      --danger:#ef4444;
      --shadow:0 6px 18px rgba(0,0,0,0.12);
    }
    body.theme-dark{
      --fg:#e6edf3;
      --fg-muted:#9fb6c7;
      --card-bg:rgba(12,18,28,0.65);
      --card-brd:1px solid rgba(255,255,255,0.08);
      --chip-bg:rgba(255,255,255,0.9);
      --chip-fg:#0b1220;
      --shadow:0 8px 22px rgba(0,0,0,0.35);
    }
    html,body,#map{height:100%;margin:0}
    .card{background:var(--card-bg);color:var(--fg);border:var(--card-brd);box-shadow:var(--shadow);border-radius:10px}
    .hud{position:absolute;top:10px;left:50%;transform:translateX(-50%);padding:10px 12px;font:12px system-ui,Arial;z-index:10050;pointer-events:none}
    .hud b{color:var(--accent)}
    .status-hud{position:absolute;bottom:10px;left:10px;padding:8px 10px;font:12px system-ui,Arial;z-index:9999;pointer-events:none;display:flex;align-items:center;gap:10px}
    .hud,.status-hud,.coords-hud{background:var(--card-bg);border:var(--card-brd);box-shadow:var(--shadow);border-radius:10px;color:var(--fg)}
    .wifi-bars{display:flex;gap:2px;align-items:flex-end;height:20px;margin-left:4px}
    .wifi-bar{width:4px;background:#94a3b8;border-radius:1px;transition:all 0.3s}
    .wifi-bar.active{background:var(--accent-2)}
    .wifi-bar:nth-child(1){height:6px}
    .wifi-bar:nth-child(2){height:10px}
    .wifi-bar:nth-child(3){height:14px}
    .wifi-bar:nth-child(4){height:18px}
    .coords-hud{position:absolute;bottom:10px;right:10px;padding:10px 12px;font:11px system-ui,monospace;z-index:10040;pointer-events:none;max-width:220px}
    .coords-hud b{color:var(--danger)}
    .coords-hud .coord-line{margin:2px 0}
    .battery-icon{width:34px;height:16px;border:2px solid var(--fg);position:relative;border-radius:3px;overflow:hidden;background:transparent;opacity:0.85}
    .battery-icon::after{content:"";position:absolute;right:-5px;top:50%;transform:translateY(-50%);width:4px;height:10px;background:var(--fg);border-radius:0 2px 2px 0}
    .battery-fill{height:100%;transition:width 0.3s ease;background:linear-gradient(90deg,#21c95e,#0aa34f)}
    .battery-fill.warn{background:linear-gradient(90deg,#ffb020,#ff8a00)}
    .battery-fill.crit{background:linear-gradient(90deg,#ff4d4d,#e40000)}
    /* Panneau toggles traces */
    .track-panel{position:absolute;top:50%;left:10px;transform:translateY(-50%);padding:10px 12px;font:12px system-ui,Arial;z-index:9999;pointer-events:auto}
    .track-panel,.dash-container{background:var(--card-bg);border:var(--card-brd);box-shadow:var(--shadow);border-radius:10px;color:var(--fg)}
    .track-panel label{display:flex;align-items:center;gap:8px;margin:6px 0}
    .dash-btn{display:inline-block;background:var(--chip-bg);border:var(--card-brd);border-radius:8px;padding:6px 10px;color:var(--chip-fg);text-decoration:none;font:12px system-ui;cursor:pointer}
    .ip-chip{background:var(--chip-bg);border:var(--card-brd);border-radius:16px;padding:4px 10px;font:12px system-ui;color:var(--chip-fg);min-width:140px;text-align:center}
    .toolbar{display:flex;flex-direction:column;gap:10px}
    .icon-bar{position:absolute;left:10px;top:120px;display:flex;flex-direction:column;gap:6px;z-index:10020}
    .icon-btn{width:32px;height:32px;border-radius:16px;border:1px solid rgba(0,0,0,0.25);background:var(--card-bg);color:var(--fg);display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:var(--shadow)}
    .icon-btn.menu-btn{font-weight:bold}
    .icon-bar.collapsed .icon-btn:not(.menu-btn){display:none}
    .tool-pop{position:absolute;left:50px;min-width:160px;padding:8px 10px;background:var(--card-bg);border:var(--card-brd);border-radius:8px;box-shadow:var(--shadow);font:12px system-ui;color:var(--fg);z-index:10025}
    .tool-pop .row{display:flex;align-items:center;gap:6px;margin:4px 0}
    /* Follow overlay arrows */
    .follow-north{width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:12px solid #ffffff;filter:drop-shadow(0 1px 2px rgba(0,0,0,0.4))}
    .arrow-container{display:flex;align-items:center;gap:6px;transform-origin:center center}
    .tri{width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:12px solid #37c56b;filter:drop-shadow(0 1px 2px rgba(0,0,0,0.4))}
    .tri-blue{border-bottom-color:#49a2ff}
    .tri-red{border-bottom-color:#ff4d4d}
    .tri-black{border-bottom-color:#111}
    .arrow-label{font:11px system-ui;color:var(--fg);text-shadow:0 1px 2px rgba(0,0,0,0.6)}
    .north-dot{width:14px;height:14px;border-radius:50%;border:2px solid #ffffff;box-shadow:0 1px 3px rgba(0,0,0,0.4)}

    /* Breakpoints */
    @media (max-width:480px){
      .hud{font-size:11px; max-width: 280px}
      .dash-container{max-width: 260px}
      .ip-chip{display:none}
      .status-hud{gap:8px; padding:6px 8px}
    }
    @media (min-width:481px) and (max-width:1024px){
      .hud{font-size:12px; max-width: 340px}
    }
  </style>
  <script>
    // Parseur JSON tolérant (remplace NaN/Infinity hors guillemets par null)
    function parseJsonSanitized(raw){
      try{ return JSON.parse(raw); }catch{}
      const sanitized = String(raw)
        .replace(/(^|[:,\[{]\s*)-?Infinity(\s*[,}\]])/gi, '$1null$2')
        .replace(/(^|[:,\[{]\s*)NaN(\s*[,}\]])/gi, '$1null$2');
      return JSON.parse(sanitized);
    }
    let map, gpsMarker, targetMarker, targetCircle, rawTargetMarker;
    const FOLLOW_RADIUS_M = 50; // rayon du cercle radar (m)
    const recentGps = [];
    const recentTgt = [];
    const allGps = [];
    const allTgt = [];
    const recentRawTgt = [];
    let gpsPolyline, gpsPolylineAll, tgtPolyline, tgtPolylineAll, rawTgtPolyline;
    const MAX_GPS_POINTS = 30;
    const MAX_TGT_POINTS = 30;
    const MAX_ALL_POINTS = 2000;
    let showGpsTrack = true;
    let showTgtTrack = true;
    let showGpsAll = true;
    let showTgtAll = true;
    let ws, wsConnected = false;
    let darkMode = false;
    let miniHudVisible = true; // visibilité mini-carte (global)
    // i18n minimal
    let appLang = 'fr';
    try{ const l = localStorage.getItem('app.lang'); if (l) appLang = l; }catch{}
    const i18n = {
      fr: { 'home':'Retour Dashboard','mini.toggle':'Mini-carte (on/off)','wp.add':'Ajouter WP','wp.clearAll':'Effacer tous les WP','wp.export':'Exporter','wp.import':'Importer','wp.toolbox':'Waypoints','traces.title':'Traces','center.title':'Centrer sur…','center.blue':'Bleu (GPS)','center.red':'Rouge (ROV)','center.followRov':'Follow ROV','center.waypoint':'Waypoint','wp.show':'Afficher','wp.connect':'Relier','wp.exportLabel':'Export','btn.export':'Exporter','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (long)','traces.tgtShort':'Cible (30)','traces.tgtLong':'Cible (long)' },
      en: { 'home':'Back to Dashboard','mini.toggle':'Mini-map (on/off)','wp.add':'Add WP','wp.clearAll':'Clear all WPs','wp.export':'Export','wp.import':'Import','wp.toolbox':'Waypoints','traces.title':'Tracks','center.title':'Center on…','center.blue':'Blue (GPS)','center.red':'Red (ROV)','center.followRov':'Follow ROV','center.waypoint':'Waypoint','wp.show':'Show','wp.connect':'Connect','wp.exportLabel':'Export','btn.export':'Export','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (long)','traces.tgtShort':'Target (30)','traces.tgtLong':'Target (long)' },
      de: { 'home':'Zurück zum Dashboard','mini.toggle':'Minikarte (an/aus)','wp.add':'WP hinzufügen','wp.clearAll':'Alle WPs löschen','wp.export':'Export','wp.import':'Import','wp.toolbox':'Wegpunkte','traces.title':'Spuren','center.title':'Zentrieren auf…','center.blue':'Blau (GPS)','center.red':'Rot (ROV)','center.followRov':'ROV folgen','center.waypoint':'Wegpunkt','wp.show':'Anzeigen','wp.connect':'Verbinden','wp.exportLabel':'Export','btn.export':'Export','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (lang)','traces.tgtShort':'Ziel (30)','traces.tgtLong':'Ziel (lang)' },
      es: { 'home':'Volver al panel','mini.toggle':'Mini-mapa (on/off)','wp.add':'Añadir WP','wp.clearAll':'Borrar todos','wp.export':'Exportar','wp.import':'Importar','wp.toolbox':'Waypoints','traces.title':'Trazas','center.title':'Centrar en…','center.blue':'Azul (GPS)','center.red':'Rojo (ROV)','center.followRov':'Seguir ROV','center.waypoint':'Waypoint','wp.show':'Mostrar','wp.connect':'Conectar','wp.exportLabel':'Exportar','btn.export':'Exportar','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (largo)','traces.tgtShort':'Objetivo (30)','traces.tgtLong':'Objetivo (largo)' },
      it: { 'home':'Torna al cruscotto','mini.toggle':'Mini-mappa (on/off)','wp.add':'Aggiungi WP','wp.clearAll':'Cancella tutti','wp.export':'Esporta','wp.import':'Importa','wp.toolbox':'Waypoints','traces.title':'Tracce','center.title':'Centra su…','center.blue':'Blu (GPS)','center.red':'Rosso (ROV)','center.followRov':'Segui ROV','center.waypoint':'Waypoint','wp.show':'Mostra','wp.connect':'Collega','wp.exportLabel':'Esporta','btn.export':'Esporta','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (lungo)','traces.tgtShort':'Target (30)','traces.tgtLong':'Target (lungo)' },
      zh: { 'home':'返回仪表板','mini.toggle':'小地图 (开/关)','wp.add':'添加航点','wp.clearAll':'清除航点','wp.export':'导出','wp.import':'导入','wp.toolbox':'航点','traces.title':'轨迹','center.title':'居中…','center.blue':'蓝色 (GPS)','center.red':'红色 (ROV)','center.followRov':'跟随 ROV','center.waypoint':'航点','wp.show':'显示','wp.connect':'连接','wp.exportLabel':'导出','btn.export':'导出','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (长)','traces.tgtShort':'目标 (30)','traces.tgtLong':'目标 (长)' },
      br: { 'home':'Distreiñ da zashboard','mini.toggle':'Mini-kartenn (on/off)','wp.add':'Ouzhpennañ WP','wp.clearAll':'Dilemel an holl WP','wp.export':'Ezporzhiañ','wp.import':'Enporzhiañ','wp.toolbox':'Waypointoù','traces.title':'Roudennoù','center.title':'Kreizhañ war…','center.blue':'Glas (GPS)','center.red':'Ruz (ROV)','center.followRov':'Heuliañ ar ROV','center.waypoint':'Waypoint','wp.show':'Diskouez','wp.connect':'Kevreañ','wp.exportLabel':'Ezporzh','btn.export':'Ezporzh','traces.gpsShort':'GPS (30)','traces.gpsLong':'GPS (hir)','traces.tgtShort':'Bukad (30)','traces.tgtLong':'Bukad (hir)' }
    };
    function t(key){ const d = i18n[appLang] || i18n.fr; return d[key] || i18n.fr[key] || key; }
    function setLang(l){ appLang = l || 'fr'; try{ localStorage.setItem('app.lang', appLang);}catch{}; document.documentElement.setAttribute('lang', appLang); }
    // Waypoints
    let waypoints = [];
    let wpMarkers = [];
    let wpLayer = null;
    let wpAddMode = false;
    let wpVisible = true;
    let wpConnect = false;
    let gToolbarEl = null;
    let followGps = true;  // autopan sur GPS
    let followRov = false; // autopan sur ROV
    let rovHeadingDeg = null; // cap calculé du ROV (dérivé des positions)
    let rovSpeedKn = 0;      // vitesse calculée du ROV (noeuds)
    let lastTargetTimeMs = null; // horodatage dernière maj ROV
    let rovHist = []; // historique récent pour vitesse (8s)
    // Waypoint popup dynamique
    let activeWpIdx = null;
    let wpExportFormat = 'geojson';
    
    // Icône de cible personnalisée (filtrée)
    const targetIcon = L.divIcon({
      html: '<div style="background:#ff3333;border:2px solid #fff;border-radius:50%;width:20px;height:20px;position:relative;"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:8px;height:8px;background:#fff;border-radius:50%;"></div><div style="position:absolute;top:-2px;left:50%;transform:translateX(-50%);width:2px;height:24px;background:#fff;"></div><div style="position:absolute;left:-2px;top:50%;transform:translateY(-50%);width:24px;height:2px;background:#fff;"></div></div>',
      className: 'target-icon',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });
    
    // Icône pour target brut (non filtré)
    const rawTargetIcon = L.divIcon({
      html: '<div style="background:#888;border:2px solid #ccc;border-radius:50%;width:16px;height:16px;position:relative;opacity:0.7;"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:6px;height:6px;background:#ccc;border-radius:50%;"></div></div>',
      className: 'raw-target-icon',
      iconSize: [16, 16],
      iconAnchor: [8, 8]
    });
    
    // Fonction pour créer l'icône GPS avec flèche directionnelle
    function createGpsArrowIcon(heading = 0) {
      const isValidHeading = typeof heading === 'number' && isFinite(heading);
      const rotation = isValidHeading ? heading : 0;
      
      return L.divIcon({
        html: `<div style="transform: rotate(${rotation}deg); transform-origin: center center;">
                 <div style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 24px solid #0066ff; position: relative; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));">
                   <div style="position: absolute; top: 18px; left: 50%; transform: translateX(-50%); width: 12px; height: 12px; background: #0066ff; border: 2px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>
                 </div>
               </div>`,
        className: 'gps-arrow-icon',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
      });
    }
    
    function init(){
      map = L.map('map').setView([47.0, 2.0], 13);
      // Si l'utilisateur déplace la carte, on désactive le suivi GPS
      map.on('dragstart', ()=>{ followGps = false; });
      
      // Tuiles standard (clair)
      const osmLight = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      });
      
      // Tuiles sombres
      const osmDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors, &copy; CartoDB'
      });
      
      // Commencer en mode clair
      osmLight.addTo(map);
      
      // Bouton toggle dark mode
      L.Control.DarkMode = L.Control.extend({
        onAdd: function(map) {
          const btn = L.DomUtil.create('button');
          btn.innerHTML = '🌙';
          btn.style.cssText = 'background:#fff;border:2px solid rgba(0,0,0,0.2);border-radius:4px;width:34px;height:34px;font-size:18px;cursor:pointer';
          btn.onclick = function() {
            darkMode = !darkMode;
            if (darkMode) {
              map.removeLayer(osmLight);
              osmDark.addTo(map);
              btn.innerHTML = '☀️';
              btn.style.background = '#333';
            } else {
              map.removeLayer(osmDark);
              osmLight.addTo(map);
              btn.innerHTML = '🌙';
              btn.style.background = '#fff';
            }
            // Sync thème CSS
            document.body.classList.toggle('theme-dark', darkMode);
          };
          return btn;
        }
      });
      new L.Control.DarkMode({position: 'topright'}).addTo(map);
      // Sélecteur de langue (top-right)
      L.Control.Lang = L.Control.extend({
        onAdd: function(){
          const d = L.DomUtil.create('div');
          d.style.cssText = 'background:#fff;border:2px solid rgba(0,0,0,0.2);border-radius:6px;padding:2px 4px;display:flex;align-items:center;gap:4px;font:12px system-ui;';
          d.innerHTML = '🌐 <select id="map-lang" style="border:none;background:transparent;outline:none">\
            <option value="fr">Français</option>\
            <option value="en">English</option>\
            <option value="br">Brezhoneg</option>\
            <option value="zh">中文</option>\
            <option value="de">Deutsch</option>\
            <option value="es">Español</option>\
            <option value="it">Italiano</option>\
          </select>';
          L.DomEvent.disableClickPropagation(d);
          setTimeout(()=>{ const sel=d.querySelector('#map-lang'); if(sel){ sel.value=appLang; sel.onchange=(e)=>{ setLang(e.target.value); }; } },0);
          return d;
        }
      });
      new L.Control.Lang({position:'topright'}).addTo(map);
      // Overlay OpenSeaMap (balises marines)
      const seamark = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: 'Map data: &copy; OpenStreetMap, Seamarks: &copy; OpenSeaMap'
      }).addTo(map);
      gpsMarker = L.marker([47,2], {title:'GPS', icon: createGpsArrowIcon(0)}).addTo(map);
      rawTargetMarker = L.marker([47,2], {title:'TARGET (brut)', opacity:0.6, icon: rawTargetIcon}).addTo(map);
      targetMarker = L.marker([47,2], {title:'TARGETF (filtré)', opacity:0.9, icon: targetIcon}).addTo(map);
      targetCircle = L.circle([47,2], {radius:5, color:'#f33', fillColor:'#f33', fillOpacity:0.15}).addTo(map);
      // Historique GPS complet en GRIS clair (au fond)
      gpsPolylineAll = L.polyline([], {color:'#bbbbbb', weight:2, opacity:0.8}).addTo(map);
      // Trace GPS en BLEU (30 derniers)
      gpsPolyline = L.polyline([], {color:'#0066ff', weight:3, opacity:0.8}).addTo(map);
      // Trace brute en gris léger (optionnel)
      rawTgtPolyline = L.polyline([], {color:'#888', weight:1, opacity:0.5, dashArray:'2,2'}).addTo(map);
      // Historique cible filtrée complet en GRIS clair (au fond)
      tgtPolylineAll = L.polyline([], {color:'#bbbbbb', weight:2, opacity:0.8}).addTo(map);
      // Trace cible filtrée en ROUGE (30 derniers points)
      tgtPolyline = L.polyline([], {color:'#ff3333', weight:2.5, opacity:0.9}).addTo(map);
      // Assurer que les traces colorées sont au-dessus
      gpsPolyline.bringToFront();
      tgtPolyline.bringToFront();
      targetCircle.bringToFront();

      // Ancien panneau latéral supprimé: tout est géré par la barre d'icônes
      // Mini barre verticale d'icônes (ouvrir/fermer, ajouter WP)
      const icons = document.createElement('div'); icons.className='icon-bar';
      const btnMenu = document.createElement('div'); btnMenu.className='icon-btn menu-btn'; btnMenu.textContent='☰'; btnMenu.title='Réduire/Afficher';
      const btnAdd = document.createElement('div'); btnAdd.className='icon-btn'; btnAdd.textContent='＋'; btnAdd.title=t('wp.add');
      const btnClear = document.createElement('div'); btnClear.className='icon-btn'; btnClear.textContent='🗑️'; btnClear.title=t('wp.clearAll');
      const btnExport = document.createElement('div'); btnExport.className='icon-btn'; btnExport.textContent='⤴️'; btnExport.title=t('wp.export');
      const btnImport = document.createElement('div'); btnImport.className='icon-btn'; btnImport.textContent='⤵️'; btnImport.title=t('wp.import');
      const btnHome = document.createElement('div'); btnHome.className='icon-btn'; btnHome.textContent='🏠'; btnHome.title=t('home');
      const btnCenter = document.createElement('div'); btnCenter.className='icon-btn'; btnCenter.textContent='🎯'; btnCenter.title=t('center.title');
      const btnRadar = document.createElement('div'); btnRadar.className='icon-btn'; btnRadar.textContent='📡'; btnRadar.title=t('mini.toggle');
      const btnWps = document.createElement('div'); btnWps.className='icon-btn'; btnWps.textContent='📍'; btnWps.title=t('wp.toolbox');
      const btnTrace = document.createElement('div'); btnTrace.className='icon-btn'; btnTrace.textContent='🧭'; btnTrace.title=t('traces.title');
      icons.appendChild(btnMenu);
      icons.appendChild(btnHome);
      icons.appendChild(btnCenter);
      icons.appendChild(btnAdd);
      icons.appendChild(btnClear);
      icons.appendChild(btnExport);
      icons.appendChild(btnImport);
      icons.appendChild(btnWps);
      icons.appendChild(btnRadar);
      icons.appendChild(btnTrace);
      document.body.appendChild(icons);

      // Replier/afficher toute la barre
      btnMenu.onclick = ()=>{ icons.classList.toggle('collapsed'); };
      // Retour Dashboard
      btnHome.onclick = ()=>{ location.href = '/'; };
      // Mini-menu centrage
      const pop = document.createElement('div'); pop.className='tool-pop'; pop.style.display='none'; document.body.appendChild(pop);
      function showPop(el, html){ const r = el.getBoundingClientRect(); pop.style.top = (r.top + window.scrollY) + 'px'; pop.style.left = (r.right + 8 + window.scrollX) + 'px'; pop.innerHTML = html; pop.style.display='block'; }
      function hidePop(){ pop.style.display='none'; }
      let activePopOwner = null;
      btnCenter.onclick = ()=>{
        if (activePopOwner === btnCenter && pop.style.display !== 'none') { hidePop(); return; }
        showPop(btnCenter, '<div class="row"><button id="c-blue" class="dash-btn">'+t('center.blue')+'</button></div><div class="row"><button id="c-red" class="dash-btn">'+t('center.red')+'</button></div><div class="row"><button id="c-follow-rov" class="dash-btn">'+t('center.followRov')+'</button></div><div class="row"><button id="c-wp" class="dash-btn">'+t('center.waypoint')+'</button></div>');
        activePopOwner = btnCenter;
        const cb=document.getElementById('c-blue'); if(cb) cb.onclick=()=>{ if(gpsMarker){ followRov=false; followGps=true; map.panTo(gpsMarker.getLatLng()); hidePop(); } };
        const cr=document.getElementById('c-red'); if(cr) cr.onclick=()=>{ if(targetMarker){ followGps=false; followRov=false; map.panTo(targetMarker.getLatLng()); hidePop(); } };
        const cf=document.getElementById('c-follow-rov'); if(cf) cf.onclick=()=>{ if(targetMarker){ followGps=false; followRov=true; map.panTo(targetMarker.getLatLng()); hidePop(); } };
        const cw=document.getElementById('c-wp'); if(cw) cw.onclick=()=>{ if(wpMarkers && wpMarkers.length){ followGps=false; map.panTo(wpMarkers[wpMarkers.length-1].getLatLng()); hidePop(); } };
      };
      btnAdd.onclick = ()=>{ wpAddMode = true; map.getContainer().style.cursor='crosshair'; };
      btnClear.onclick = ()=>{ waypoints = []; saveWaypoints(); refreshWaypoints(); };
      btnExport.onclick = ()=>{ exportWaypoints(wpExportFormat); };
      btnImport.onclick = ()=>{
        const inp = document.createElement('input'); inp.type='file'; inp.accept='.json,.geojson'; inp.onchange=(ev)=>{ importWaypoints(ev.target.files[0]); }; inp.click();
      };
      // Toggle mini-carte (cercle + crantages + flèches)
      try{ const v = localStorage.getItem('map.miniHudVisible'); if (v!==null) miniHudVisible = (v==='1'); }catch{}
      function setMiniHudVisible(v){ miniHudVisible = !!v; try{ localStorage.setItem('map.miniHudVisible', miniHudVisible?'1':'0'); }catch{}; if(!miniHudVisible){ clearFollowHud(); } }
      // Indication visuelle
      function refreshRadarBtn(){ btnRadar.style.opacity = miniHudVisible? '1' : '0.55'; btnRadar.style.filter = miniHudVisible? '' : 'grayscale(0.6)'; }
      refreshRadarBtn();
      btnRadar.onclick = ()=>{ setMiniHudVisible(!miniHudVisible); refreshRadarBtn(); };

      // Initialiser waypoints et gérer l'ajout par clic sur la carte
      try{
        const v = localStorage.getItem('map.wps.visible'); if (v!==null) wpVisible = (v==='1');
        const c = localStorage.getItem('map.wps.connect'); if (c!==null) wpConnect = (c==='1');
        const ef = localStorage.getItem('wp.exportFormat'); if (ef) wpExportFormat = ef;
      }catch{}
      loadWaypoints();
      refreshWaypoints();
      map.on('click', (e)=>{
        if (!wpAddMode) return;
        addWaypoint(e.latlng.lat, e.latlng.lng);
        wpAddMode = false; map.getContainer().style.cursor='';
      });
      // Popups outils simples pour Waypoints/Traces
      btnWps.onclick = ()=>{ 
        if (activePopOwner === btnWps && pop.style.display !== 'none') { hidePop(); return; }
        const fmtSel = (wpExportFormat||'geojson');
        showPop(btnWps, '<div class="row"><input id="wp-show2" type="checkbox" '+(wpVisible?'checked':'')+'> '+t('wp.show')+'</div>'+
                           '<div class="row"><input id="wp-connect2" type="checkbox" '+(wpConnect?'checked':'')+'> '+t('wp.connect')+'</div>'+
                           '<div class="row"><label style="min-width:56px">'+t('wp.exportLabel')+'</label><select id="wp-export-format"><option value="geojson">GeoJSON</option><option value="kml">KML</option><option value="csv">CSV</option></select><button id="wp-export-go" class="dash-btn">'+t('btn.export')+'</button></div>');
        activePopOwner = btnWps;
        const s=document.getElementById('wp-show2'); if(s) s.onchange=(e)=>{ wpVisible=e.target.checked; refreshWaypoints(); localStorage.setItem('map.wps.visible', wpVisible?'1':'0'); };
        const c=document.getElementById('wp-connect2'); if(c) c.onchange=(e)=>{ wpConnect=e.target.checked; localStorage.setItem('map.wps.connect', wpConnect?'1':'0'); refreshWaypoints(); };
        const sel=document.getElementById('wp-export-format'); if(sel){ sel.value = fmtSel; sel.onchange=(e)=>{ wpExportFormat = e.target.value; try{ localStorage.setItem('wp.exportFormat', wpExportFormat);}catch{} }; }
        const go=document.getElementById('wp-export-go'); if(go){ go.onclick=()=>{ exportWaypoints(wpExportFormat); }; }
      };
      btnTrace.onclick = ()=>{ 
        if (activePopOwner === btnTrace && pop.style.display !== 'none') { hidePop(); return; }
        showPop(btnTrace, '<div class="row"><input id="tgps" type="checkbox" '+(showGpsTrack?'checked':'')+'> '+t('traces.gpsShort')+'</div><div class="row"><input id="tgpsall" type="checkbox" '+(showGpsAll?'checked':'')+'> '+t('traces.gpsLong')+'</div><div class="row"><input id="ttgt" type="checkbox" '+(showTgtTrack?'checked':'')+'> '+t('traces.tgtShort')+'</div><div class="row"><input id="ttgtall" type="checkbox" '+(showTgtAll?'checked':'')+'> '+t('traces.tgtLong')+'</div>');
        activePopOwner = btnTrace;
        const f=(id,cb)=>{ const e=document.getElementById(id); if(e) e.onchange=cb; };
        f('tgps', (e)=>{ showGpsTrack=e.target.checked; updateTrackVisibility(); });
        f('tgpsall', (e)=>{ showGpsAll=e.target.checked; updateTrackVisibility(); });
        f('ttgt', (e)=>{ showTgtTrack=e.target.checked; updateTrackVisibility(); });
        f('ttgtall', (e)=>{ showTgtAll=e.target.checked; updateTrackVisibility(); });
      };
      // Fermer au clic en dehors
      document.addEventListener('click', (ev)=>{
        if (pop.style.display==='none') return;
        if (pop.contains(ev.target) || ev.target===activePopOwner) return;
        hidePop();
      });
      // Plus de panneau latéral: icône ☰ en haut de la barre suffit
      // Sync classe thème à l'ouverture
      document.body.classList.toggle('theme-dark', darkMode);
      connectWs();
      refreshHud(); 
      // Reforcer rafraîchissement au premier affichage (mobile peut bloquer setInterval au chargement)
      setTimeout(refreshHud, 800);
      setInterval(refreshHud, 1500);
    }

    function updateTrackVisibility(){
      if (showGpsTrack){ if (!map.hasLayer(gpsPolyline)) gpsPolyline.addTo(map); }
      else { if (map.hasLayer(gpsPolyline)) map.removeLayer(gpsPolyline); }
      if (showGpsAll){ if (!map.hasLayer(gpsPolylineAll)) gpsPolylineAll.addTo(map); }
      else { if (map.hasLayer(gpsPolylineAll)) map.removeLayer(gpsPolylineAll); }
      if (showTgtTrack){ if (!map.hasLayer(tgtPolyline)) tgtPolyline.addTo(map); }
      else { if (map.hasLayer(tgtPolyline)) map.removeLayer(tgtPolyline); }
      if (showTgtAll){ if (!map.hasLayer(tgtPolylineAll)) tgtPolylineAll.addTo(map); }
      else { if (map.hasLayer(tgtPolylineAll)) map.removeLayer(tgtPolylineAll); }
    }

    // --- Waypoints helpers ---
    function loadWaypoints(){
      try{ const raw = localStorage.getItem('map.wps'); waypoints = raw? JSON.parse(raw): []; }catch{ waypoints = []; }
    }
    function saveWaypoints(){ localStorage.setItem('map.wps', JSON.stringify(waypoints||[])); }
    function addWaypoint(lat, lon){
      waypoints.push({lat, lon}); saveWaypoints(); refreshWaypoints();
    }
    function clearWpLayer(){ if (wpMarkers){ for (const m of wpMarkers){ map.removeLayer(m); } } wpMarkers = []; if (wpLayer){ map.removeLayer(wpLayer); wpLayer=null; } }
    function refreshWaypoints(){
      clearWpLayer();
      if (!wpVisible || !waypoints || waypoints.length===0) { const info=document.getElementById('wp-info'); if(info) info.textContent='0 WP · 0.0 km'; return; }
      // Générer une étiquette courte A1..Z9
      function shortName(i){ const letter = String.fromCharCode(65 + (i % 26)); const num = 1 + ((i / 26) | 0) % 9; return letter + num; }
      for (let i=0;i<waypoints.length;i++){
        const wp = waypoints[i];
        const label = shortName(i);
        const html = `<div style=\"display:flex;align-items:center;gap:4px\"><div style=\"width:10px;height:10px;border:2px solid #111;background:#ffd166;border-radius:50%\"></div><div style=\"font-size:10px;background:#111;color:#fff;padding:1px 3px;border-radius:3px\">${label}</div></div>`;
        const icon = L.divIcon({html, className:'', iconSize:[26,14], iconAnchor:[13,7]});
        const mk = L.marker([wp.lat, wp.lon], {icon, title:'Waypoint '+label}).addTo(map);
        mk.on('click', ()=>{ activeWpIdx = i; showWpBearingDistance(wp.lat, wp.lon, label); });
        wpMarkers.push(mk);
      }
      // Polyline optionnelle
      if (typeof wpConnect !== 'undefined' && wpConnect) {
        const latlngs = waypoints.map(w=>[w.lat, w.lon]);
        wpLayer = L.polyline(latlngs, {color:'#111', opacity:0.4, weight:2, dashArray:'4,4'}).addTo(map);
      }
      let dist=0; for (let i=1;i<waypoints.length;i++){ dist += haversine(waypoints[i-1], waypoints[i]); }
      const info=document.getElementById('wp-info'); if(info) info.textContent=`${waypoints.length} WP · ${dist.toFixed(1)} km`;
    }
    function haversine(a,b){
      const R=6371; const dLat=(b.lat-a.lat)*Math.PI/180; const dLon=(b.lon-a.lon)*Math.PI/180; const la1=a.lat*Math.PI/180; const la2=b.lat*Math.PI/180; const s=Math.sin(dLat/2)**2+Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(s));
    }
    function exportWaypoints(fmt){
      const pts = waypoints||[];
      fmt = (fmt||'geojson').toLowerCase();
      if (fmt==='csv'){
        const header = 'name,lat,lon\n';
        const rows = pts.map((w,i)=>`${String.fromCharCode(65+(i%26))}${1+((i/26)|0)%9},${w.lat.toFixed(7)},${w.lon.toFixed(7)}`).join('\n');
        const blob = new Blob([header+rows+'\n'], {type:'text/csv'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='waypoints.csv'; a.click(); URL.revokeObjectURL(a.href); return;
      }
      if (fmt==='kml'){
        const placemarks = pts.map((w,i)=>`<Placemark><name>${String.fromCharCode(65+(i%26))}${1+((i/26)|0)%9}</name><Point><coordinates>${w.lon.toFixed(7)},${w.lat.toFixed(7)},0</coordinates></Point></Placemark>`).join('');
        const kml = `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>${placemarks}</Document></kml>`;
        const blob = new Blob([kml], {type:'application/vnd.google-earth.kml+xml'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='waypoints.kml'; a.click(); URL.revokeObjectURL(a.href); return;
      }
      // geojson
      const gj = {type:'FeatureCollection', features:pts.map((w,i)=>({type:'Feature',properties:{name:`${String.fromCharCode(65+(i%26))}${1+((i/26)|0)%9}`},geometry:{type:'Point',coordinates:[w.lon,w.lat]}}))};
      const blob = new Blob([JSON.stringify(gj,null,2)], {type:'application/json'});
      const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='waypoints.geojson'; a.click(); URL.revokeObjectURL(a.href);
    }
    function showWpBearingDistance(lat, lon, label){
      // Référence ROV (target filtrée) si dispo, sinon GPS, sinon centre
      const ref = (lastTargetLat!=null && lastTargetLon!=null)? {lat:lastTargetLat, lon:lastTargetLon} : (lastGps || {lat: map.getCenter().lat, lon: map.getCenter().lng});
      const brg = bearingDeg(ref.lat, ref.lon, lat, lon);
      const dkm = haversine({lat:ref.lat,lon:ref.lon},{lat,lon});
      const popupHtml = `<div style="font:12px system-ui"><b>${label}</b><br><span id="wp-brg">Brg: ${brg.toFixed(1)}°</span><br><span id="wp-dist">Dist: ${(dkm*1000).toFixed(0)} m</span></div>`;
      const p = L.popup({autoClose:true, closeButton:true}).setLatLng([lat,lon]).setContent(popupHtml).openOn(map);
      p.on('remove', ()=>{ activeWpIdx = null; });
    }
    function bearingDeg(lat1, lon1, lat2, lon2){
      const toRad = (x)=>x*Math.PI/180, toDeg=(x)=>x*180/Math.PI;
      const dLon = toRad(lon2-lon1); const y = Math.sin(dLon)*Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1))*Math.sin(toRad(lat2)) - Math.sin(toRad(lat1))*Math.cos(toRad(lat2))*Math.cos(dLon);
      let brg = toDeg(Math.atan2(y,x)); if (brg<0) brg+=360; return brg;
    }
    async function importWaypoints(file){
      if (!file) return; const txt = await file.text();
      try{ const obj = JSON.parse(txt); const feats = obj.type==='FeatureCollection'? obj.features : []; const pts = feats.filter(f=>f.geometry&&f.geometry.type==='Point'); waypoints = pts.map(f=>({lat:f.geometry.coordinates[1], lon:f.geometry.coordinates[0]})); saveWaypoints(); refreshWaypoints(); }catch(e){ console.error('Import WP error', e); }
    }
    function connectWs(){
      try{
        ws = new WebSocket(`ws://${location.hostname}:81/`);
        ws.onopen = ()=>{ wsConnected = true; };
        ws.onclose = ()=>{ wsConnected = false; setTimeout(connectWs, 1000); };
        ws.onmessage = (ev)=>{
          const data = ev?.data;
          if (typeof data !== 'string') return;
          const s = data.trim();
          if (!s) return;
          if (s[0] !== '{' || s[s.length-1] !== '}') return; // ignorer NMEA/logs
          try{
            const msg = JSON.parse(s);
            if (msg.gps) updateGPS(msg.gps);
            if (msg.targetf) { if (msg.targetf.filtered) updateTargetF(msg.targetf); else updateRawTarget(msg.targetf); }
            if (msg.rssi !== undefined) updateWifiDisplay(msg.rssi);
          }catch(_){
            try{
              const msg = parseJsonSanitized(s);
              if (msg.gps) updateGPS(msg.gps);
              if (msg.targetf) { if (msg.targetf.filtered) updateTargetF(msg.targetf); else updateRawTarget(msg.targetf); }
              if (msg.rssi !== undefined) updateWifiDisplay(msg.rssi);
            }catch(__){ /* ignorer */ }
          }
        };
      }catch(e){ console.log(e); setTimeout(connectWs, 1000); }
    }
    // --- Follow HUD (cercle + flèches) ---
    let followHud = null;
    function ensureFollowHud(){
      if (followHud) return followHud;
      const hud = L.layerGroup();
      hud.addTo(map);
      followHud = {group:hud, circle:null, arrows:[]};
      return followHud;
    }
    function clearFollowHud(){ if(!followHud) return; followHud.group.clearLayers(); followHud.circle=null; followHud.arrows=[]; }
    function updateFollowHud(centerLatLng, headingDeg){
      if (!miniHudVisible) { clearFollowHud(); return; }
      const hud = ensureFollowHud();
      hud.group.clearLayers(); hud.arrows=[];
      // Cercle jaune autour du centre
      hud.circle = L.circle(centerLatLng, {radius: FOLLOW_RADIUS_M, color:'#ffd400', weight:2, opacity:0.9, fill:false}).addTo(hud.group);
      // Crantages (ticks) internes: mineurs 30°, majeurs 90°
      drawTicks(centerLatLng, FOLLOW_RADIUS_M);
      // (échelle supprimée, le rayon est connu de l'UI)
      // Nord (triangle blanc) + repère de couleur au nord selon cible suivie
      placeArrow(centerLatLng, 0, FOLLOW_RADIUS_M, 'follow-north');
      placeNorthMarker(centerLatLng);
      // Flèches vers éléments visibles: dernier targetF, GPS, et waypoints
      if (targetMarker){ placeArrow(centerLatLng, bearing(centerLatLng, targetMarker.getLatLng()), FOLLOW_RADIUS_M, 'tri-red'); }
      if (gpsMarker){ placeArrow(centerLatLng, bearing(centerLatLng, gpsMarker.getLatLng()), FOLLOW_RADIUS_M, 'tri-blue'); }
      if (Array.isArray(wpMarkers)){
        for (let i=0;i<wpMarkers.length;i++){ 
          const mk = wpMarkers[i];
          const lbl = String.fromCharCode(65 + (i % 26)) + (1 + ((i/26)|0)%9);
          placeArrow(centerLatLng, bearing(centerLatLng, mk.getLatLng()), FOLLOW_RADIUS_M, 'tri-black', lbl);
        }
      }
      // (option désactivée) indicateur de cap: retiré à la demande
    }
    // function drawScaleChip(...) supprimée
    function placeNorthMarker(center){
      // Choisir la couleur en fonction du mode de suivi
      let htmlDot = '<div class="north-dot" style="background:#49a2ff"></div>';
      if (followRov) htmlDot = '<div class="north-dot" style="background:#ff4d4d"></div>';
      const p = destPoint(center, 0, FOLLOW_RADIUS_M);
      const icon = L.divIcon({className:'', html: htmlDot, iconSize:[14,14], iconAnchor:[7,7]});
      const m = L.marker(p, {icon});
      m.addTo(followHud.group);
    }
    function drawTicks(center, radiusM){
      const minorLen = 12;   // m
      const majorLen = 22;   // m
      const isDark = document.body.classList.contains('theme-dark');
      const colMinor = isDark ? '#e6e6e6' : '#6b7280'; // gris plus soutenu en mode clair
      const colMajor = isDark ? '#f3f4f6' : '#374151'; // plus contrasté en clair
      const opMinor = isDark ? 0.5 : 0.45;
      const opMajor = isDark ? 0.7 : 0.6;
      for (let deg=0; deg<360; deg+=30){
        const isMajor = (deg % 90) === 0;
        const len = isMajor ? majorLen : minorLen;
        const r2 = radiusM - 2; // bord extérieur (proche du cercle)
        const r1 = r2 - len;    // intérieur
        const p1 = destPoint(center, deg*Math.PI/180, r1);
        const p2 = destPoint(center, deg*Math.PI/180, r2);
        L.polyline([p1,p2], {color: isMajor? colMajor : colMinor, weight: isMajor? 2: 1, opacity: isMajor? opMajor: opMinor}).addTo(followHud.group);
      }
    }
    function placeArrow(origin, bearingDeg, radiusM, css, label){
      const p = destPoint(origin, bearingDeg*Math.PI/180, radiusM);
      const colorClass = (css==='tri-blue'||css==='tri-red'||css==='tri-black')? css : null;
      const triClass = colorClass? `tri ${colorClass}` : (css==='follow-north'? 'follow-north' : 'tri');
      const html = label? `<div class="arrow-container" style="transform:rotate(${bearingDeg-180}deg)"><div class="${triClass}"></div><div class="arrow-label" style="transform:rotate(180deg)">${label}</div></div>` : `<div class="${triClass}" style="transform:rotate(${bearingDeg-180}deg)"></div>`;
      const div = L.divIcon({className:'', html, iconSize:[60,16], iconAnchor:[30,8]});
      const m = L.marker(p, {icon:div});
      m.addTo(followHud.group);
      followHud.arrows.push(m);
    }
    function destPoint(origin, angleRad, distM){
      const R=6378137; const d=distM; const lat=origin.lat*Math.PI/180, lon=origin.lng*Math.PI/180; const br=angleRad; const lat2 = Math.asin(Math.sin(lat)*Math.cos(d/R)+Math.cos(lat)*Math.sin(d/R)*Math.cos(br)); const lon2 = lon + Math.atan2(Math.sin(br)*Math.sin(d/R)*Math.cos(lat), Math.cos(d/R)-Math.sin(lat)*Math.sin(lat2));
      return L.latLng(lat2*180/Math.PI, lon2*180/Math.PI);
    }
    function bearing(a, b){
      const toRad=(x)=>x*Math.PI/180, toDeg=(x)=>x*180/Math.PI; const lat1=toRad(a.lat), lon1=toRad(a.lng), lat2=toRad(b.lat), lon2=toRad(b.lng); const dLon=lon2-lon1; const y=Math.sin(dLon)*Math.cos(lat2); const x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon); let br=toDeg(Math.atan2(y,x)); if (br<0) br+=360; return br;
    }
    function updateWifiDisplay(rssi) {
      if (rssi === undefined || rssi === null) return;
      
      let icon = '📡', quality = 'Déconnecté';
      // Réinitialiser les barres
      for (let i = 1; i <= 4; i++) {
        const bar = document.getElementById(`bar${i}`);
        if (bar) bar.className = 'wifi-bar';
      }
      
      if (rssi !== 0) {
        let bars = 0;
        let barColor = '#555';
        
        if (rssi >= -50) { 
          icon = '📶'; 
          quality = 'Excellent'; 
          bars = 4;
          barColor = '#4CAF50';
        } else if (rssi >= -60) { 
          icon = '📶'; 
          quality = 'Très bon'; 
          bars = 3;
          barColor = '#8BC34A';
        } else if (rssi >= -70) { 
          icon = '📶'; 
          quality = 'Bon'; 
          bars = 2;
          barColor = '#FFC107';
        } else if (rssi >= -80) { 
          icon = '📶'; 
          quality = 'Faible'; 
          bars = 1;
          barColor = '#FF9800';
        } else { 
          icon = '📵'; 
          quality = 'Très faible'; 
          bars = 1;
          barColor = '#F44336';
        }
        
        // Animer les barres actives
        for (let i = 1; i <= bars; i++) {
          const bar = document.getElementById(`bar${i}`);
          if (bar) {
            bar.className = 'wifi-bar active';
            bar.style.backgroundColor = barColor;
          }
        }
        
        // Mise à jour du texte
        const wifiIcon = document.getElementById('wifi-icon');
        const wifiQuality = document.getElementById('wifi-quality');
        const wifiRssi = document.getElementById('wifi-rssi');
        
        if (wifiIcon) wifiIcon.textContent = icon;
        if (wifiQuality) wifiQuality.textContent = quality;
        if (wifiRssi) wifiRssi.textContent = rssi + ' dBm';
      }
      
      console.log('WiFi updated via WS - RSSI:', rssi, 'Quality:', quality);
    }
    
    let lastGps = null;
    function updateGPS(g){
      if (!g || typeof g.lat !== 'number' || typeof g.lon !== 'number' || !isFinite(g.lat) || !isFinite(g.lon)) return;
      const lat=g.lat, lon=g.lon;
      // ignorer la coordonnée 0,0 pure qui n'est pas exploitable
      if ((lat === 0 && lon === 0)) return;
      lastGps = {lat, lon};
      
      // Mettre à jour la position du marqueur
      gpsMarker.setLatLng([lat,lon]);
      
      // Mettre à jour l'icône avec l'orientation si heading disponible
      if (g.hdg !== undefined && g.hdg !== null && isFinite(g.hdg)) {
        const newIcon = createGpsArrowIcon(g.hdg);
        gpsMarker.setIcon(newIcon);
        console.log('GPS marker updated with heading:', g.hdg + '°');
      }
      
      recentGps.push([lat,lon]); if (recentGps.length>MAX_GPS_POINTS) recentGps.shift();
      gpsPolyline.setLatLngs(recentGps);
      // Historique complet GPS (borné)
      if (allGps.length===0 || Math.abs(allGps[allGps.length-1][0]-lat)>1e-6 || Math.abs(allGps[allGps.length-1][1]-lon)>1e-6){
        allGps.push([lat,lon]); if (allGps.length>MAX_ALL_POINTS) allGps.shift();
        gpsPolylineAll.setLatLngs(allGps);
      }
      let mlat=0, mlon=0; for (const p of recentGps){ mlat+=p[0]; mlon+=p[1]; }
      mlat/=recentGps.length; mlon/=recentGps.length;
      const c = map.getCenter(); const dLat=Math.abs(c.lat-mlat), dLon=Math.abs(c.lng-mlon);
      if (followGps && (dLat>0.0002 || dLon>0.0002)) map.panTo([mlat,mlon], {animate:true,duration:0.4});
      // Mettre à jour le HUD de suivi autour du GPS si on suit le GPS
      if (followGps) updateFollowHud(L.latLng(mlat, mlon), g.hdg);
      
      // ✅ Mettre à jour le heading GPS dans le HUD en temps réel
      if (g.hdg !== undefined && g.hdg !== null) {
        console.log('GPS heading updated via WS:', g.hdg);
        // Le HUD sera mis à jour par refreshHud() mais on peut forcer ici
        updateHeadingInHud(g.hdg);
      }
    }
    
    // Fonction helper pour mettre à jour seulement le heading dans le HUD
    function updateHeadingInHud(heading) {
      const hud = document.getElementById('hud');
      if (hud && hud.innerHTML) {
        // Remplacer seulement la ligne CAP GPS dans le HUD existant
        const currentHtml = hud.innerHTML;
        const headingLine = `<div><b>CAP GPS</b> <span style="background:#2563eb;color:white;padding:2px 6px;border-radius:4px;font-weight:bold;margin-left:4px">${heading?.toFixed?.(1) || '--'}°</span></div>`;
        
        // Regex pour remplacer la ligne CAP GPS existante
        const updatedHtml = currentHtml.replace(/<div><b>CAP GPS<\/b>.*?<\/div>/, headingLine);
        
        if (updatedHtml !== currentHtml) {
          hud.innerHTML = updatedHtml;
        }
      }
    }
    let lastRawTargetLat = null, lastRawTargetLon = null;
    function updateRawTarget(t){
      if (!t || typeof t.lat !== 'number' || typeof t.lon !== 'number') {
        return;
      }
      
      const lat = t.lat;
      const lon = t.lon;
      
      // Vérifier si la position a changé
      const posChanged = (lastRawTargetLat === null || lastRawTargetLon === null ||
                         Math.abs(lastRawTargetLat - lat) > 0.000001 || 
                         Math.abs(lastRawTargetLon - lon) > 0.000001);
      
      if (posChanged) {
        console.log('Raw target:', {lat: lat.toFixed(6), lon: lon.toFixed(6)});
        
        // Mise à jour du marqueur brut
        rawTargetMarker.setLatLng([lat, lon]);
        
        // Mise à jour de la trace brute
        if (recentRawTgt.length === 0 || 
            Math.abs(recentRawTgt[recentRawTgt.length-1][0] - lat) > 0.00001 || 
            Math.abs(recentRawTgt[recentRawTgt.length-1][1] - lon) > 0.00001) {
          recentRawTgt.push([lat, lon]); 
          if (recentRawTgt.length > 20) recentRawTgt.shift();
          rawTgtPolyline.setLatLngs(recentRawTgt);
        }
        
        lastRawTargetLat = lat;
        lastRawTargetLon = lon;
      }
    }
    
    let lastTargetLat = null, lastTargetLon = null;
    function updateTargetF(t){
      if (!t || typeof t.lat !== 'number' || typeof t.lon !== 'number') {
        console.warn('Invalid target data:', t);
        return;
      }
      
      const lat = t.lat;
      const lon = t.lon;
      const r95 = t.r95_m || 5;
      
      // Vérifier si la position a vraiment changé
      const posChanged = (lastTargetLat === null || lastTargetLon === null ||
                         Math.abs(lastTargetLat - lat) > 0.000001 || 
                         Math.abs(lastTargetLon - lon) > 0.000001);
      
      if (posChanged) {
        console.log('Target moved to:', {lat: lat.toFixed(6), lon: lon.toFixed(6), r95: r95.toFixed(1), filtered: t.filtered || false});
        
        // Mise à jour des marqueurs
        targetMarker.setLatLng([lat, lon]);
        targetCircle.setLatLng([lat, lon]); 
        targetCircle.setRadius(r95);
        
        // Mise à jour de la trace
        if (recentTgt.length === 0 || 
            Math.abs(recentTgt[recentTgt.length-1][0] - lat) > 0.00001 || 
            Math.abs(recentTgt[recentTgt.length-1][1] - lon) > 0.00001) {
          recentTgt.push([lat, lon]); 
          if (recentTgt.length > MAX_TGT_POINTS) recentTgt.shift();
          tgtPolyline.setLatLngs(recentTgt);
        }
        // Historique complet cible filtrée (borné)
        if (allTgt.length===0 || Math.abs(allTgt[allTgt.length-1][0]-lat)>1e-6 || Math.abs(allTgt[allTgt.length-1][1]-lon)>1e-6){
          allTgt.push([lat,lon]); if (allTgt.length>MAX_ALL_POINTS) allTgt.shift();
          tgtPolylineAll.setLatLngs(allTgt);
        }
        
        // Mise à jour des coordonnées affichées
        document.getElementById('targetf-lat').textContent = lat.toFixed(6);
        document.getElementById('targetf-lon').textContent = lon.toFixed(6);
        document.getElementById('targetf-r95').textContent = r95.toFixed(1) + ' m';
        
        // Calcul heading/vitesse ROV et centrage si suivi activé
        const nowMs = Date.now();
        if (lastTargetLat !== null && lastTargetLon !== null && lastTargetTimeMs !== null){
          // Lisser la vitesse sur ~8 secondes
          rovHist.push({t:nowMs, lat, lon});
          // garder 10s d'historique max
          const cutoff = nowMs - 8000; // 8s pour lisser
          rovHist = rovHist.filter(p=>p.t >= cutoff);
          const first = rovHist[0];
          const last = rovHist[rovHist.length-1];
          if (first && last && last.t>first.t){
            const dKm = haversine({lat:first.lat, lon:first.lon}, {lat:last.lat, lon:last.lon});
            const dtH = (last.t - first.t) / 3600000;
            rovSpeedKn = (dKm / Math.max(0.0001, dtH)) * 0.539957; // km/h -> kts
            rovHeadingDeg = bearingDeg(lastTargetLat, lastTargetLon, lat, lon);
          }
        }
        lastTargetTimeMs = nowMs;
        lastTargetLat = lat;
        lastTargetLon = lon;
        if (followRov) {
          map.panTo([lat, lon], {animate:true, duration:0.4});
          updateFollowHud(L.latLng(lat,lon), null);
        }
      }
    }
    async function refreshHud(){
      try{
        const r = await fetch('/api/telemetry', {cache:'no-store'});
        const txt = await r.text();
        const j = parseJsonSanitized(txt);
        if (!j || typeof j !== 'object') { console.warn('API telemetry vide'); return; }
        const hud = document.getElementById('hud');
        // Statut RTK (badge compact)
        let gpsStatusBadge = '';
        if (j.gps?.status) {
          const statusColors = { 'RTK Fix': '#22c55e', 'RTK Float': '#fbbf24', 'DGPS': '#3b82f6', 'Natural': '#9E9E9E' };
          const color = statusColors[j.gps.status] || '#9E9E9E';
          gpsStatusBadge = `<span style="background:${color};color:${j.gps.status === 'RTK Float' ? 'black' : 'white'};padding:1px 6px;border-radius:10px;font-size:11px;margin-left:6px">${j.gps.status}</span>`;
        }

        // Heure UTC uniquement
        const now = new Date();
        const utcDate = now.toLocaleDateString('fr-FR', { day:'2-digit', month:'2-digit', year:'numeric', timeZone:'UTC' });
        const utcTime = now.toLocaleTimeString('fr-FR', { hour:'2-digit', minute:'2-digit', second:'2-digit', timeZone:'UTC' });

        // Distance corrigée (si target filtrée disponible et GPS connu)
        let corrM = null;
        if (j.targetf && typeof j.targetf.lat === 'number' && typeof j.targetf.lon === 'number' && lastGps) {
          corrM = Math.round(haversine({lat:lastGps.lat, lon:lastGps.lon}, {lat:j.targetf.lat, lon:j.targetf.lon}) * 1000);
        }

        const gpsLine = `<div><b>GPS</b>${gpsStatusBadge} | sats ${j.gps?.sats??'-'} | hdop ${j.gps?.hdop??'-'} | CAP ${j.gps?.hdg?.toFixed?.(1) ?? '--'}°${j.gps?.speed_kn!==undefined?` | vit ${j.gps.speed_kn.toFixed?.(2)} kts`:''}</div>`;
        const seakerLine = `<div><b>SEAKER</b> ${j.seaker?.status||''} | ang ${j.seaker?.angle?.toFixed?.(1)||'-'}° | dist ${j.seaker?.dist?.toFixed?.(1)||'-'} m${corrM!==null?` | corr ${corrM} m`:''}</div>`;
        const rovInfo = `<div><b>ROV</b> cap ${rovHeadingDeg?.toFixed?.(1) ?? '--'}° | vit ${rovSpeedKn?.toFixed?.(2) ?? '0.00'} kts</div>`;
        hud.innerHTML = `
          <div><b>UTC</b> ${utcDate} ${utcTime}</div>
          ${gpsLine}
          ${seakerLine}
          ${rovInfo}
        `;
        // Mise à jour de la puce IP
        const chip = document.getElementById('ip-chip');
        if (chip){ chip.textContent = j.ip || 'IP —'; chip.dataset.ip = j.ip || ''; }
        
        // Mise à jour du GPS depuis l'API
        if (j.gps && typeof j.gps.lat === 'number' && typeof j.gps.lon === 'number' && isFinite(j.gps.lat) && isFinite(j.gps.lon)) {
          updateGPS({lat: j.gps.lat, lon: j.gps.lon, hdg: j.gps.hdg});
        }
        
        // Mise à jour du targetF depuis l'API (fallback si WebSocket ne fonctionne pas)
        if (j.targetf && typeof j.targetf.lat === 'number' && typeof j.targetf.lon === 'number') {
          console.log('API targetf:', j.targetf);
          // L'API renvoie toujours la dernière position connue (filtrée ou non)
          updateRawTarget(j.targetf);
          // On considère que si c'est dans l'API, c'est la dernière position valide
          updateTargetF(j.targetf);
          
          // Mise à jour des coordonnées affichées (au cas où updateTargetF ne se déclenche pas)
          document.getElementById('targetf-lat').textContent = j.targetf.lat.toFixed(6);
          document.getElementById('targetf-lon').textContent = j.targetf.lon.toFixed(6);
          document.getElementById('targetf-r95').textContent = (j.targetf.r95_m || 0).toFixed(1) + ' m';
        }
        
        // Mise à jour de la batterie (max 11.2V)
        if (j.power) {
          const v = j.power.voltage;
          const i = j.power.current_mA;
          const pct = Math.max(0, Math.min(100, ((v - 9.2) / (11.2 - 9.2)) * 100));
          const fill = document.getElementById('battery-fill');
          if (fill) {
          fill.style.width = pct + '%';
          // Seuils ajustés: critique < 9.5V, warning < 10.0V
          fill.className = 'battery-fill' + (v < 9.5 ? ' crit' : (v < 10.0 ? ' warn' : ''));
          }
          const bv = document.getElementById('battery-voltage'); if (bv) bv.textContent = v.toFixed(2) + ' V';
          const bi = document.getElementById('battery-current'); if (bi) bi.textContent = i.toFixed(0) + ' mA';
        }
        
        // Mise à jour du signal WiFi
        if (j.rssi !== undefined && j.rssi !== null) {
          const rssi = j.rssi;
          let icon = '📡', quality = 'Déconnecté';
          // Réinitialiser les barres
          for (let i = 1; i <= 4; i++) {
            const b = document.getElementById(`bar${i}`);
            if (b) b.className = 'wifi-bar';
          }
          
          if (rssi !== 0) {
            let bars = 0;
            let barColor = '#555';
            
            if (rssi >= -50) { 
              icon = '📶'; 
              quality = 'Excellent'; 
              bars = 4;
              barColor = '#4CAF50';
            } else if (rssi >= -60) { 
              icon = '📶'; 
              quality = 'Très bon'; 
              bars = 3;
              barColor = '#8BC34A';
            } else if (rssi >= -70) { 
              icon = '📶'; 
              quality = 'Bon'; 
              bars = 2;
              barColor = '#FFC107';
            } else if (rssi >= -80) { 
              icon = '📵'; 
              quality = 'Faible'; 
              bars = 1;
              barColor = '#FF9800';
            } else { 
              icon = '📵'; 
              quality = 'Très faible'; 
              bars = 1;
              barColor = '#F44336';
            }
            
            // Activer les barres correspondantes
            for (let i = 1; i <= bars; i++) {
              const bar = document.getElementById(`bar${i}`);
              if (bar) {
              bar.className = 'wifi-bar active';
              bar.style.background = barColor;
              }
            }
            // pas d'icône wifi, on ne met à jour que les barres
          } else {
            icon = '❌';
            quality = 'Déconnecté';
            // sans icône
          }
          
          const wq = document.getElementById('wifi-quality'); if (wq) wq.textContent = quality;
          const wr = document.getElementById('wifi-rssi'); if (wr) wr.textContent = rssi + ' dBm';
          
          // Debug
          console.log('WiFi RSSI:', rssi, 'Quality:', quality);
        } else {
          console.log('No RSSI data in API response');
        }

        // Mise à jour temps réel du popup WP si ouvert
        if (activeWpIdx!=null && waypoints[activeWpIdx]){
          const wp = waypoints[activeWpIdx];
          const ref = (lastTargetLat!=null && lastTargetLon!=null)? {lat:lastTargetLat, lon:lastTargetLon} : (lastGps || null);
          if (ref){
            const brg = bearingDeg(ref.lat, ref.lon, wp.lat, wp.lon);
            const dkm = haversine({lat:ref.lat,lon:ref.lon},{lat:wp.lat,lon:wp.lon});
            const eB = document.getElementById('wp-brg'); if (eB) eB.textContent = `Brg: ${brg.toFixed(1)}°`;
            const eD = document.getElementById('wp-dist'); if (eD) eD.textContent = `Dist: ${(dkm*1000).toFixed(0)} m`;
          }
        }
      }catch(e){console.error('Erreur refreshHud:', e);}
    }
    window.addEventListener('load', init);
  </script>
</head>
<body>
  <div id="map"></div>
  <div id="hud" class="hud">...</div>
  <div id="status-hud" class="status-hud">
    <div class="battery-icon"><div id="battery-fill" class="battery-fill" style="width:0%"></div></div>
    <div class="wifi-bars">
      <div class="wifi-bar" id="bar1"></div>
      <div class="wifi-bar" id="bar2"></div>
      <div class="wifi-bar" id="bar3"></div>
      <div class="wifi-bar" id="bar4"></div>
    </div>
  </div>
  <div id="coords-hud" class="coords-hud">
    <div><b>TARGETF</b></div>
    <div class="coord-line">Lat: <span id="targetf-lat">--.------</span></div>
    <div class="coord-line">Lon: <span id="targetf-lon">--.------</span></div>
    <div class="coord-line">R95: <span id="targetf-r95">--.- m</span></div>
  </div>
</body>
</html>


